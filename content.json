{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"网络与系统-进程间通信","slug":"网络与系统-进程间通信2（上传）","date":"2021-01-25T15:42:15.030Z","updated":"2021-01-25T15:41:55.000Z","comments":true,"path":"2021/01/25/网络与系统-进程间通信2（上传）/","link":"","permalink":"http://example.com/2021/01/25/%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A12%EF%BC%88%E4%B8%8A%E4%BC%A0%EF%BC%89/","excerpt":"","text":"网络与系统-进程间通信实现多进程累加求和 共享内存实现（bug)功能描述： 利用共享内存来实现多进程累加求和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// 还有bug，调bug/************************************************************************* &gt; File Name: 1.add.c &gt; Mail: 1136984246@qq.com ************************************************************************/#include &quot;head.h&quot;#define INS 5// 共享内存中的内容：计算数据 + 同步数据 struct Num &#123; int now; int sum; pthread_mutex_t mutex; pthread_cond_t cond;&#125;;struct Num *share_memory;void do_add(int x) &#123; while (1) &#123; // ？条件变量为什么要和互斥量一起用， 两者到底有什么区别？ pthread_mutex_lock(&amp;share_memory-&gt;mutex); pthread_cond_wait(&amp;share_memory-&gt;cond, &amp;share_memory-&gt;mutex); int flag = 0; // ? 一个进程在一个cpu时间片中可以完成几个数的累加 for (int i = 0; i &lt; 1000; i++) &#123; if (share_memory-&gt;now &gt; 1000) &#123; // 完成最后加法的子进程进程解锁 pthread_mutex_unlock(&amp;share_memory-&gt;mutex); // ? 防止父亲发了信号，但是孩子没有收到（单核系统）， 多核系统可能不存在 pthread_cond_signal(&amp;share_memory-&gt;cond); exit(0); &#125; // 数据累加 share_memory-&gt;sum += share_memory-&gt;now; share_memory-&gt;now++; printf(&quot;&lt;%d&gt; now = %d, sum = %d\\n&quot;, x, share_memory-&gt;now, share_memory-&gt;sum); // ? 刷新标准输出 fflush(stdout); &#125; // 任意一个子进程完成计算后进行解锁并发送信号 pthread_mutex_unlock(&amp;share_memory-&gt;mutex); pthread_cond_signal(&amp;share_memory-&gt;cond); &#125; exit(0);&#125;int main() &#123; pid_t pid; int x = 0, shmid; // 创建唯一的IPC key值 key_t key = ftok(&quot;.&quot;, 2021); // printf(&quot;key = %d\\n&quot;, key); // key 值可以为负数 // 创建一个共享内存段，如果key值对应的共享内存段存在则返回错误 // IPC : file exits -&gt; 1. // 0666 : 666权限 if ((shmid = shmget(key, sizeof(struct Num), IPC_CREAT | IPC_EXCL | 0666)) &lt; 0) &#123; perror(&quot;shmget&quot;); exit(1); &#125; // 将共享内存段附加给调用进程, 使进程可以引用该共享内存段 // shmaddr = NULL : 该段被内核分配到一个合理的地址 // shmaddr + shmflg : 决定共享内存段如何附加在进程中 读、写 share_memory = (struct Num *)shmat(shmid, NULL, 0); // 返回： 共享内存段的地址 if (share_memory &lt; 0) &#123; perror(&quot;share_memory&quot;); exit(1); &#125; // 父进程中共享内存段初始化 share_memory-&gt;now = 0; share_memory-&gt;sum = 0; // 互斥量属性设置 pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); // 把进程间互斥共享属性的值设为1 pthread_mutexattr_setpshared(&amp;attr, 1); // 初始共享内存段中的互斥量 pthread_mutex_init(&amp;share_memory-&gt;mutex, &amp;attr); // 条件变量属性设置 pthread_condattr_t c_attr; pthread_condattr_init(&amp;c_attr); pthread_condattr_setpshared(&amp;c_attr, 1); // 初始化共享内存段中的条件变量 pthread_cond_init(&amp;share_memory-&gt;cond, &amp;c_attr); for (int i = 1; i &lt;= INS; i++) &#123; // fork() : 子进程继承父进程附加的共享内存段 if ((pid = fork()) &lt; 0) &#123; perror(&quot;fork()&quot;); &#125; x = i; if (pid == 0) break; &#125; if (pid == 0) &#123; do_add(x); &#125; else &#123; // 避免信号被忽略：父进程先sleep后面再发送信号 sleep(1); // 父进程发送信号 pthread_cond_signal(&amp;share_memory-&gt;cond); // 父进程给所有子进程收尸 for (int i = 1; i &lt;= INS; i++) &#123; wait(NULL); &#125; &#125; // 父进程输出最终累加和 printf(&quot;share_memory-&gt;sum = %d\\n&quot;, share_memory-&gt;sum); // 分离共享内存段，进程将无法使用该共享内存 shmdt(share_memory); // 删除共享内存段 // ? 参数 shmctl(shmid, IPC_RMID, NULL); return 0;&#125; 文件锁实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/************************************************************************* &gt; File Name: 2.sum.c &gt; Mail: 1136984246@qq.com ************************************************************************/// 命令行参数解析 ins : 父进程收尸， 子进程计算// 所有孩子抢着做：死循环，直到计算完毕；子进程两种状态：等，算； // 多进程的通讯：文件与文件锁 : 读文件，写文件； 锁的作用：保证每一次只有一个进程对文件进行读写#include &quot;head.h&quot;char data_file[] = &quot;./data&quot;; // 存储当前进程得到的加数，以及前面若干进程求得的累加和char lock_file[] = &quot;./lock&quot;; // ?// 文件中存储两个数据： 当前的加数，当前的累加和struct Msg &#123; int now; int sum;&#125;;// 定义并初始化数据变量为零（父进程中） struct Msg data;// 将数据写文件size_t set_data(struct Msg *msg) &#123; FILE *f = fopen(data_file, &quot;w&quot;); if (f == NULL) &#123; perror(&quot;fopen()&quot;); exit(1); &#125; size_t nwrite = fwrite(msg, 1, sizeof(struct Msg), f); //写入方式： 元素的大小为1字节，元素的个数 sizeof(struct Msg); fclose(f); // ? 会自动去除锁吗？ return nwrite; // 返回写入字节数，以及判断是否写入成功&#125;// 读取文件中数据size_t get_data(struct Msg *msg) &#123; FILE *f = fopen(data_file, &quot;r&quot;); if (f == NULL) &#123; perror(&quot;fopen()&quot;); exit(1); &#125; size_t nread = fread(msg, 1, sizeof(struct Msg), f); // ? 一个一个字节的写？ fclose(f); // ? 关闭文件 会 自动关闭文件锁吗? return nread;&#125;// 思路1： 两个文件，使用单独的文件作为锁// 思路2： 一个文件，直接在数据文件中加锁void do_count(int end, int id) &#123; // 通过死循环实现多进程之间抢锁 while (1) &#123; FILE *lock = fopen(lock_file, &quot;w&quot;); // 若lock_file 不存在则创建 if (lock == NULL) &#123; perror(&quot;fopen()&quot;); exit(1); &#125; // 加锁与解锁之间是原子操作 // 给文件加互斥锁，持有锁的进程想后面进行，其他的进程阻塞 // 加锁 flock(lock-&gt;_fileno, LOCK_EX); // lock-&gt;_fileno 等价于 fd : 文件指针与文件描述符之间的转换 // 读取数据文件 if (!get_data(&amp;data)) &#123; flock(lock-&gt;_fileno, LOCK_UN); // 如果读取数据失败则释放锁，并且重新再抢锁 continue; &#125; // 加数加1，并且判断是否满足停止加的条件 if (++data.now &gt; end) &#123; fclose(lock); break; &#125; // 求累计和 data.sum += data.now; printf(&quot;&lt;%d&gt; child : now = %d, sum = %d\\n&quot;, id, data.now, data.sum); // 将数据写入文件 if (!set_data(&amp;data)) continue; // 解锁 flock(lock-&gt;_fileno, LOCK_UN); fclose(lock); // 关闭文件后也会自动释放锁 &#125; &#125;int main(int argc, char ** argv) &#123; // 获取命令行参数 int opt, start, end, ins; if (argc != 7) &#123; fprintf(stderr, &quot;Usage : %s -s start_num -e end_num -i ins\\n&quot;, argv[0]); exit(1); &#125; while ((opt = getopt(argc, argv, &quot;s:e:i:&quot;)) != -1) &#123; switch (opt) &#123; case &#x27;s&#x27; : &#123; start = atoi(optarg); // atoi : 字符串转整数 break; &#125; case &#x27;e&#x27; : &#123; end = atoi(optarg); break; &#125; case &#x27;i&#x27; : &#123; ins = atoi(optarg); break; &#125; default : &#123; fprintf(stderr, &quot;Usage : %s -s start_num -e end_num -i ins\\n&quot;, argv[0]); exit(1); &#125; &#125; &#125; // 父进程：初始化data文件数据 if (!set_data(&amp;data)) return -1; // 父进程负责生孩子 pid_t pid; int x = 0; for (int i = 1; i &lt;= ins; i++) &#123; if ((pid = fork()) &lt; 0) &#123; perror(&quot;fork()&quot;); exit(1); &#125; if (pid == 0) &#123; x = i; break; &#125; &#125; // 子进程负责计算 if (pid == 0) &#123; do_count(end, x); &#125; else &#123; // 替所有的子进程收尸 for (int i = 1; i &lt;= ins; i++) &#123; wait(NULL); &#125; // 父进程输出最终答案 if (!(get_data(&amp;data))) return -1; printf(&quot;sum = %d\\n&quot;, data.sum); &#125; return 0;&#125;/************************************************************************* &gt; File Name: head.h &gt; Mail: 1136984246@qq.com ************************************************************************/#include &quot;common.h&quot;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/file.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/ipc.h&gt; 简易聊天室（bug)功能描述：通过共享内存实现多用户聊天 启动服务端 客户端1发送信息到服务端，服务端接受信息并打印 客户端2发送信息到服务端，服务端接受信息并打印 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168// 有bug 还需要调 bug// 客户端/************************************************************************* &gt; File Name: client.c &gt; Mail: 1136984246@qq.com ************************************************************************/#include &quot;head.h&quot;#include &quot;chat.h&quot;// 客户端 ： 一个客户使用该共享内存时，其他客户不能够使用struct Msg *share_memory;int main(int argc, char **argv) &#123; int opt, shmid; char name[20]; while((opt = getopt(argc, argv, &quot;n:&quot;)) != -1) &#123; switch(opt) &#123; case &#x27;n&#x27; : &#123; strcpy(name, optarg); break; &#125; default : &#123; fprintf(stderr, &quot;Usage : %s -n name\\n&quot;, argv[0]); exit(1); &#125; &#125; &#125; // 客户端和服务度你的key值是一样的，但是不在同一个共享内存 key_t key = ftok(&quot;.&quot;, 202101); if ((shmid = shmget(key, sizeof(struct Msg), IPC_CREAT | 0666)) &lt; 0) &#123; perror(&quot;shmget()&quot;); exit(1); &#125; if ((share_memory = shmat(shmid, NULL, 0)) &lt; 0) &#123; perror(&quot;shmat()&quot;); exit(1); &#125; while (1) &#123; // 输入聊天信息 char msg[1024] = &#123;0&#125;; // 聊天内容可能存在空格等 scanf(&quot;%[^\\n]s&quot;, msg); // 吞掉流中的&#x27;\\n&#x27; getchar(); // 聊天信息为空则继续读入 if (!strlen(msg)) continue; // 将聊天信息写入共享内存 // 下面while会有什么风险？，尝试其他的内容 pthread_mutex_trylock ? while (1) &#123; if (!strlen(share_memory-&gt;msg)) &#123; pthread_mutex_lock(&amp;share_memory-&gt;mutex); break; &#125; &#125; printf(&quot;Client is sending &lt;%s&gt;...\\n&quot;, msg); strcpy(share_memory-&gt;msg, msg); strcpy(share_memory-&gt;name, name); pthread_cond_signal(&amp;share_memory-&gt;cond); // bug : 客户端发送信号后，服务端就开始抢锁，但是此时客户端持有锁 printf(&quot;Client is sending cond signal!\\n&quot;); pthread_mutex_unlock(&amp;share_memory-&gt;mutex); &#125; return 0;&#125;// 服务端/************************************************************************* &gt; File Name: server.c &gt; Mail: 1136984246@qq.com ************************************************************************/#include &quot;head.h&quot;#include &quot;chat.h&quot; // 服务端的功能 ： 1. 先启动进行初始化 2. 客户端发送消息，服务端进行打印struct Msg *share_memory = NULL;int main() &#123; int shmid; key_t key = ftok(&quot;.&quot;, 202101); // ? 缺少 IPC_EXPLS ：聊天室不需要吗？ if ((shmid = shmget(key, sizeof(struct Msg), IPC_CREAT | 0666)) &lt; 0) &#123; perror(&quot;shmid()&quot;); exit(1); &#125; // if ((share_memory = shmat(shmid, NULL, 0)) &lt; 0) &#123; perror(&quot;shmat()&quot;); exit(1); &#125; // 服务端先启动，初始化共享内存 memset(share_memory, 0, sizeof(struct Msg)); // pthread_mutexattr_t m_attr; pthread_mutexattr_init(&amp;m_attr); // ？ PTHREAD_PROCESS_SHARED == 1; pthread_mutexattr_setpshared(&amp;m_attr, PTHREAD_PROCESS_SHARED); pthread_mutex_init(&amp;share_memory-&gt;mutex, &amp;m_attr); // pthread_condattr_t c_attr; pthread_condattr_init(&amp;c_attr); // 在linux下自动被忽略 pthread_condattr_setpshared(&amp;c_attr, PTHREAD_PROCESS_SHARED); pthread_cond_init(&amp;share_memory-&gt;cond, &amp;c_attr); while (1) &#123; pthread_mutex_lock(&amp;share_memory-&gt;mutex); printf(&quot;Server Gets the lock!\\n&quot;); // 只要客户端发送信息就需要发送信息给服务端 share_memory-&gt;cond; // share_meory-&gt;mutex : 避免刚要等，但是信息已经错过 pthread_cond_wait(&amp;share_memory-&gt;cond, &amp;share_memory-&gt;mutex); printf(&quot;Server got the cond signal!\\n&quot;); printf(&quot;&lt;%s&gt; : %s\\n&quot;, share_memory-&gt;name, share_memory-&gt;msg); pthread_mutex_unlock(&amp;share_memory-&gt;mutex); &#125; return 0;&#125;// 头文件/************************************************************************* &gt; File Name: chat.h &gt; Mail: 1136984246@qq.com ************************************************************************/#ifndef _CHAT_H#define _CHAT_Hstruct Msg &#123; char name[20]; char msg[1024]; pthread_mutex_t mutex; pthread_cond_t cond;&#125;;#endif/************************************************************************* &gt; File Name: head.h &gt; Mail: 1136984246@qq.com ************************************************************************/#include &quot;common.h&quot;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/file.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/ipc.h&gt;void make_nonblock(int fd);void make_block(int fd); 常用函数 函数 注意事项 共享内存： 无内核介入，速度快 int shmget(key_t key, size_t size, int shmflg) 返回标识符; IPC_EXCL : file exits;shm flg ：共享内存段权限；位掩码（按位或） void *shmat(int shmid, const void *shmaddr, int shmflg) 返回共享内存段的地址（强转）；shmaddr + shmflg决定附加方式； int shmdt(const void *shmaddr) 先分离 int shmctl(int shmid, int cmd, struct shmid_ds *buf) 后删除 key_t ftok(const char *pathname, int proj_id) IPC key唯一，但是key对应的ipc 标识符可以不唯一 条件变量：允许线程阻塞和等待另一个线程发送信号 常与互斥锁一起用 int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr) int pthread_cond_signal(pthread_cond_t *cond) 发送信号；适用于所有线程执行相同任务pthread_cond_signal vs pthread_cond_broadcast；无线程等（信号丢失）； int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex) 等待信号 int pthread_condattr_init(pthread_condattr_t *attr) ？ 属性值为1 pthread_condattr_setpshared 互斥锁 ：同一时间只有一个线程访问数据 串行化数据访问； int pthread_mutex_lock(pthread_mutex_t *mutex) int pthread_mutex_unlock(pthread_mutex_t *mutex) int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr) NULL：默认值； 只能初始化一次？； int pthread_mutexattr_setpshared(const pthread_mutexattr_t *attr, int pshared) set 与 get是一对 ：设置进程共享属性的值 int pthread_mutexattr_init(pthread_mutattr_t *mutattr) 初始化互斥量属性 线程： pthread_create 结构体传参；线程终止； pthread_exit 线程自杀 pthread_join 共享内存共享内存的步骤 常用命令shmget: file exits 命令 用法 ipcs 进程间通信资源信息 ipcrm 删除ipc 多线程编程创建线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************************************************************* &gt; File Name: 1.test.c &gt; Mail: 1136984246@qq.com ************************************************************************/#include &quot;head.h&quot;// 结构体作为传入参数struct MyArg &#123; char name[20]; int age;&#125;;void *print(void *arg) &#123; // 传参操作1： 通过指针直接修改原来数据 struct MyArg *in_p = (struct MyArg *)arg; printf(&quot;In Thread!\\n&quot;); printf(&quot;%s is %d years old\\n&quot;,in_p-&gt;name, in_p-&gt;age); // arg的地址不变，仍然是主函数中age的地址 // 传参操作2： 建立变量进行赋值操作，推荐 struct MyArg in = *(struct MyArg *)arg; printf(&quot;%s is %d years old\\n&quot;, in.name, in.age); // 传参操作3：假如有100个客户，每个客户都需要传参，如何保证不同的参数都不重复 ? // 在主函数中进行维护，建立一个数组，里面存入数据的地址，保证线程传参数时传入不同的地址即可&#125;int main() &#123; pthread_t thread; char name[20]; int age = 18; struct MyArg arg; strcpy(arg.name, &quot;yuanqin&quot;); arg.age = age; // 传参的过程中 int err = pthread_create(&amp;thread, NULL, print, &amp;arg); if (err != 0)&#123; perror(&quot;pthread_create()&quot;); exit(1); &#125; printf(&quot;In Main\\n&quot;); sleep(1); // usleep(1) 有 bug return 0;&#125; 线程池(bug : 段错误)基本思路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163// bug/************************************************************************* &gt; File Name: thread_pool.h &gt; Mail: 1136984246@qq.com ************************************************************************/#ifndef THREAD_POOL_H#define THREAD_POOL_Hstruct task_queue &#123; int size; int total; int head, tail; char **data; pthread_mutex_t mutex; pthread_cond_t cond;&#125;;void task_queue_init(struct task_queue *q, int size);void task_queue_push(struct task_queue *q, char *str);char *task_queue_pop(struct task_queue *q);#endif/************************************************************************* &gt; File Name: thread_pool.c &gt; Mail: 1136984246@qq.com ************************************************************************/#include &quot;head.h&quot;#include &quot;thread_pool.h&quot; void task_queue_init(struct task_queue * q, int size) &#123; q-&gt;size = size; q-&gt;total = q-&gt;head = q-&gt;tail = 0; q-&gt;data = (char **)calloc(size, sizeof(char *)); // calloc初始化为0 pthread_mutex_init(&amp;q-&gt;mutex, NULL); pthread_cond_init(&amp;q-&gt;cond, NULL);&#125;void task_queue_push(struct task_queue *q, char *str) &#123; pthread_mutex_lock(&amp;q-&gt;mutex); if (q-&gt;total == q-&gt;size) &#123; printf(&quot;The queue is full !\\n&quot;); pthread_mutex_unlock(&amp;q-&gt;mutex); return; &#125; printf(&quot;&lt;push&gt; : %s\\n&quot;, str); q-&gt;data[q-&gt;tail++] = str; q-&gt;total++; if (q-&gt;tail == q-&gt;size) &#123; printf(&quot;The queue reachs the end!\\n&quot;); q-&gt;tail = 0; &#125; // 进来一位客人之后要发送信号 pthread_cond_signal(&amp;q-&gt;cond); pthread_mutex_unlock(&amp;q-&gt;mutex); return;&#125;char *task_queue_pop(struct task_queue *q) &#123; pthread_mutex_lock(&amp;q-&gt;mutex); // 当队列中的人数为零，就要开始抢人，等信号 // while : 抢到的退出，没有抢到的继续等下一次信号 while (q-&gt;total == 0) &#123; printf(&quot;Queue is empty!\\n&quot;); pthread_cond_wait(&amp;q-&gt;cond, &amp;q-&gt;mutex); &#125; printf(&quot;&lt;pop&gt; : %s\\n&quot;, q-&gt;data[q-&gt;head]); q-&gt;total--; if (++q-&gt;head == q-&gt;size) &#123; printf(&quot;Queue reach the end!\\n&quot;); q-&gt;head = 0; &#125; pthread_mutex_unlock(&amp;q-&gt;mutex);&#125;/************************************************************************* &gt; File Name: test.c &gt; Mail: 1136984246@qq.com ************************************************************************/#include &quot;head.h&quot;#include &quot;thread_pool.h&quot;#define THREAD 5#define QUEUE 50// 打印读取的内容并且弹出任务队列void *do_work(void *arg) &#123; pthread_detach(pthread_self()); // ? 专心干自己的工作 struct task_queue *q = (struct task_queue *)arg; while (1) &#123; char *str = task_queue_pop(q); printf(&quot;&lt;%ld&gt; : %s\\n&quot;, pthread_self(), str); &#125;&#125;int main() &#123; // 初始化 pthread_t tid[THREAD]; // 线程池 struct task_queue q; task_queue_init(&amp;q, QUEUE); char buff[QUEUE][1024] = &#123;0&#125;; // 创建线程完成任务 for (int i = 0; i &lt; THREAD; i++) &#123; pthread_create(&amp;tid[i], NULL, do_work, (void *)&amp;q); &#125; // 循环读取当前文件的代码并且写入队列中 int sub = 0; while (1) &#123; FILE *fp = fopen(&quot;./test.c&quot;, &quot;r&quot;); // ? &quot;w&quot; if (fp == NULL) &#123; perror(&quot;fopen()&quot;); exit(1); &#125; // 按行读取 while (fgets(buff[sub++], 1024, fp) != NULL) &#123; task_queue_push(&amp;q, buff[sub]); // 循环的读 // ? buff 需要清空吗？ if (sub == QUEUE) &#123; sub = 0; &#125; if (q.total == q.size) &#123; // 线程导致队列元素的弹出 while (1) &#123; if (q.total &lt; q.size) &#123; break; &#125; // 让子线程处理任务队列，让cpu转起来 usleep(10000); &#125; &#125; &#125; fclose(fp); &#125; return 0;&#125;/************************************************************************* &gt; File Name: head.h &gt; Mail: 1136984246@qq.com ************************************************************************/#include &quot;common.h&quot;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/file.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/ipc.h&gt;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"系统编程","slug":"计算机/系统编程","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"系统编程与网络编程","slug":"系统编程与网络编程","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"笔算7-搜索走地图1","slug":"笔算7-搜索走地图1","date":"2021-01-25T15:38:04.245Z","updated":"2021-01-25T15:38:04.245Z","comments":true,"path":"2021/01/25/笔算7-搜索走地图1/","link":"","permalink":"http://example.com/2021/01/25/%E7%AC%94%E7%AE%977-%E6%90%9C%E7%B4%A2%E8%B5%B0%E5%9C%B0%E5%9B%BE1/","excerpt":"","text":"笔算7-搜索走地图1背景 类型 特点 深搜走地图 栈（递归）；连通性问题； 广搜走地图 队列；连通性问题+最短路径问题；按层遍历 深搜走地图连通性问题定义： 深度优化搜索定义： 深度搜索走地图形状 注意： 14点： 广搜走地图广度优化搜索定义： 广搜走地图的形状 dfs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/************************************************************************* &gt; File Name: dfs.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 深度搜索和广度搜索的本质都是：暴力枚举// 走地图的思路： 1. 如何走（方向数组） 2. 如何存储地图：数组越界问题（1,1）点，不用判断边界#include&lt;iostream&gt;using namespace std;int n, m, sx, sy;int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;; // 方向的顺序不重要 上右下左char mmap[105][105];// 以sx，sy为起点能否找到终点int func(int x, int y) &#123; // 以起点四个方向走 for (int i = 0; i &lt; 4; i++) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; // (1, 1) /* if (xx == 0 || yy == 0 || xx &gt; n || yy &gt; m) &#123; continue; &#125; */ if (mmap[xx][yy] == &#x27;T&#x27;) &#123; return 1; &#125; if (mmap[xx][yy] == &#x27;.&#x27;) &#123; mmap[xx][yy] = &#x27;#&#x27;; // 避免重复搜索 ： 死循环 // 深搜就是一个递归的活 if (func(xx, yy)) &#123; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; // 数组越界问题:从（1,1）点，不用判断边界 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mmap[i][j]; if (mmap[i][j] == &#x27;S&#x27;) &#123; sx = i; sy = j; &#125; &#125; &#125; if (func(sx, sy)) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; bfs 1 oj535 123456789101112131415161718192021222324252627282930313233343536373839/************************************************************************* &gt; File Name: oj535.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 连通性问题 #include&lt;iostream&gt;using namespace std;int n, m, sx, sy, ans = 1; // 脚下黑砖也算int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;char mmap[55][55];void func(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (mmap[xx][yy] == &#x27;.&#x27;) &#123; ans++; mmap[xx][yy] = 0; // 可为非&#x27;.&#x27;任意数 func(xx, yy); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mmap[i][j]; if (mmap[i][j] == &#x27;@&#x27;) &#123; sx = i, sy = j; &#125; &#125; &#125; func(sx, sy); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; leetcode200 leetcode130用广度搜索 oj398 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/************************************************************************* &gt; File Name: oj398.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/#include&lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, step;&#125;;int n, m, x, y;int ans[450][450];// 8个方向， 边界也需要改变 int dir[8][2] = &#123;1, 2, 1, -2, 2, 1, 2, -1, -1, 2, -1, -2,-2, 1, -2, -1&#125;;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; // 全部初始化为-1,或是用mark数组 memset(ans, -1, sizeof(ans)); // 按字节赋值，-1, 0可以， 1 不可以 queue&lt;node&gt; que; que.push((node)&#123;x, y, 0&#125;); ans[x][y] = 0; while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 8; i++) &#123; int x = temp.x +dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m || ans[x][y] != -1) &#123; continue; &#125; ans[x][y] = temp.step + 1; que.push((node)&#123;x, y, ans[x][y]&#125;); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j != 1) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; ans[i][j]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; oj304 往外移动5个格子 oj396123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/************************************************************************* &gt; File Name: oj396.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 思路1 ： 边界的0（没被围起来的0）， 4条边界 or 外围补0 -&gt; 搜索 // 思路2 ： 利用广义搜索解决连通性问题#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y;&#125;;int n, num[50][50];int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; num[i][j]; &#125; &#125; queue&lt;node&gt; que; que.push((node)&#123;0, 0&#125;); num[0][0] = 3; // while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 0 || y &lt; 0 || x &gt; n + 1 || y &gt; n + 1 || num[x][y] != 0) &#123; continue; &#125; num[x][y] = 3; que.push((node)&#123;x, y&#125;); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (j != 1) &#123; cout &lt;&lt; &quot; &quot;; &#125; if (num[i][j] == 0) &#123; cout &lt;&lt; 2; &#125; else if (num[i][j] == 1) &#123; cout &lt;&lt; 1; &#125; else &#123; cout &lt;&lt; 0; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"面试笔试算法","slug":"计算机/面试笔试算法","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"面试笔试算法","slug":"面试笔试算法","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95/"}]},{"title":"","slug":"笔算1-编码能力提升","date":"2021-01-22T02:12:44.765Z","updated":"2021-01-22T02:12:44.765Z","comments":true,"path":"2021/01/22/笔算1-编码能力提升/","link":"","permalink":"http://example.com/2021/01/22/%E7%AC%94%E7%AE%971-%E7%BC%96%E7%A0%81%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87/","excerpt":"","text":"笔算1-编码能力提升[TOC] 面试笔试算法(上)课程介绍内容 编码能力提升 二分专题(注重细节) leetcode刷题入门 海贼oj典型题 简单介绍STL(不深究原理, 重视应用) 搜索(递归, 排列组合, 走地图, 综合) 形式讲知识点 -&gt; 读题 -&gt; 讲题 -&gt; 课后作业 学习方法实践类(主要是做题) 重视基础, 不断反复练习简单的题, 简单的, 才是常考的. 做题方法 看题解思路, 不是看代码, 会思路就应该会写代码, 否则编码能力太差 尝试暴力解, 然后看怎么优化 做题: 千万别只做一遍 作业海贼oj上的题中的递归题目改成递归 + 记忆化 递归+记忆化递归递归过程分为展开和回溯, 展开的过程是压栈, 回溯的过程是弹栈。如果递归函数太深, 会爆栈。 这是因为递归函数展开时所产生的局部变量和代码地址存入栈区中，而操作系统分配给一个进程的栈空间是2M。（思考：能否改变堆栈的空间？） 递归的过程中展开的过程中有些项反复计算， 比如斐波那契数列 记忆化递归求解中用全局数组的方式记录计算过的值，对于记录值，无需继续向下递归，可以直接返回。 斐波那契数列求解方法比较递推实现123456789101112131415161718192021222324/************************************************************************* &gt; File Name: fib_v3.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 递推： 超大规模的全局数组#include&lt;iostream&gt;using namespace std;#define N 4000000int fib[N + 5]; // 全局区定义数组，自动初始化为零int main() &#123; long long ans = 2; fib[1] = 1, fib[2] = 2; for (int i = 3; 1 ; i++) &#123; fib[i] = fib[i - 1] + fib[i - 2]; if (fib[i] &gt; N) break; if (fib[i] % 2 == 0) &#123; ans += fib[i]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 改进 : 降低空间复杂度，超大数组改为两个变量 12345678910111213141516171819202122/************************************************************************* &gt; File Name: fib_v1.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 递推实现：fab(n) = fab(n - 1) + fab(n - 2)#include&lt;iostream&gt;using namespace std;#define N 4000000int main() &#123; int ans = 0, a = 1, b = 2; while (b &lt;= N) &#123; if (b % 2 == 0) &#123; ans += b; &#125; b = a + b; a = b - a; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 递归实现12345678910111213141516171819202122232425262728293031/************************************************************************* &gt; File Name: fib_v2.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 递归实现#include&lt;iostream&gt;#define N 4000000using namespace std;int fib(int n) &#123; if (n == 2) &#123; return 2; &#125; if (n == 1) &#123; return 1; &#125; return fib(n - 1) + fib(n - 2);&#125;int main() &#123; int ans = 0, temp = 0; for (int i = 1; 1; i++) &#123; if (fib(i) &gt; N) break; if (fib(i)% 2 == 0) &#123; ans += fib(i); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 记忆化递归12345678910111213141516171819202122232425262728293031323334/************************************************************************* &gt; File Name: fib_v5.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/#include&lt;iostream&gt;using namespace std;#define N 4000000// fib_num[n]记录着fib(n)的值int fib_num[N];int fib(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; if (n &lt; N &amp;&amp; fib_num[n]) return fib_num[n]; return fib_num[n] = fib(n - 1) + fib(n - 2);&#125;int main() &#123; int ans = 0; for (int i = 1; 1; i++) &#123; // 调用 fib(i)可能递归求解，若之前求解过，直接返回 if (fib(i) &gt; N) &#123; break; &#125; // 再次调用 fib(i)，函数当数组用 if (fib(i) % 2 == 0) &#123; ans += fib(i); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 时空复杂度分析 方法 计算效率 原理 递归： 函数调用像二叉树 展开+回溯 ：由未知-&gt;已知边界-&gt;已知 fib(4), fib(4) = fib (3) + fib(2) -&gt; fib(3) = fib(2) + fib(1) -&gt; 已知fib(1), fib(2) -&gt; 回溯 记忆化递归： 接近于递推 递归的基础上，消除展开过程中重复项 递推： 由已知推向未知fib(1) + fib(2) -&gt; fib(3), fib(2) + fib(3) -&gt; fib(4), .... 思考 什么情况是牺牲时间换空间？ 什么情况是牺牲空间换时间？ 最长考拉兹序列123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#define N 1000000using namespace std;// 全局变量初始化为零int num[N + 5]; // func(n)的返回值为第n个数字迭代生成的序列的长度, 其中n有可能超过int类型int func(long long n) &#123; if (n == 1) return 1; // 判断 fun(n)是否标记 if (n &lt; N &amp;&amp; num[n]) &#123; // 写成 if (num[n] &amp;&amp; n &lt; N) 会出现段错误 return num[n]; &#125; int t; // 记录 func(n)的迭代次数 // 单条序列不可能重复，否则就死循环 13-&gt;40-&gt;20 ...5-&gt;16-&gt;8..假如为 -&gt;5-&gt;16-&gt;8.. if (n % 2 == 0) &#123; t = func(n / 2) + 1; // 回溯t &#125; else &#123; t = func(3 * n + 1) + 1; &#125; // 回溯 if (n &lt; N) &#123; num[n] = t; &#125; // n &gt; N 时 ? return t;&#125;int main() &#123; int ans = 1; for (int i = 1; i &lt; N; i++) &#123; if (func(ans) &lt; func(i)) &#123; ans = i; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 方向数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/************************************************************************* &gt; File Name: euler11.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/#include&lt;iostream&gt;using namespace std;int num[30][30]; // 外圈围绕一层零且防止越界// 上右，右，下右，下int dirx[4] = &#123;-1, 0, 1, 1&#125;;int diry[4] = &#123;1, 1, 1, 0&#125;;int main() &#123; for (int i = 5; i &lt; 25; i++) &#123; for (int j = 5; j &lt; 25; j++) &#123; // 从文件中通过管道输入 cin &gt;&gt; num[i][j]; &#125; &#125; // 以最左上角进行移动 int ans = 0; for (int i = 5; i &lt; 25; i++) &#123; for (int j = 5; j &lt; 25; j++) &#123; for (int k = 0; k &lt; 4; k++) &#123; int t = num[i][j]; // 局部变量的作用域 放在第二层循环中定义就会出问题 // cout &lt;&lt; num[i][j]; for (int l = 1; l &lt; 4; l++) &#123; int x = i + dirx[k] * l; int y = j + diry[k] * l; // cout &lt;&lt; &quot;*&quot; &lt;&lt; num[x][y]; // 当t为0时 t *= num[x][y]; &#125; if (ans &lt; t) &#123; ans = t; &#125; // ans = max(ans ,t); // cout &lt;&lt; endl; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 滑动窗口法12","categories":[],"tags":[]},{"title":"","slug":"笔算2-编码能力提升2","date":"2021-01-22T02:00:45.196Z","updated":"2021-01-22T02:00:45.196Z","comments":true,"path":"2021/01/22/笔算2-编码能力提升2/","link":"","permalink":"http://example.com/2021/01/22/%E7%AC%94%E7%AE%972-%E7%BC%96%E7%A0%81%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%872/","excerpt":"","text":"笔算2-编码能力提升2大整数（高精度）计算大整数加法思路 字符串读入大整数 整形数组存储倒序大整数 大整数对齐相加 处理进位 输出答案 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/************************************************************************* &gt; File Name: add.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/#include&lt;iostream&gt;#include &lt;cstring&gt;using namespace std;char num1[1005], num2[1005]; int n1[1005], n2[1005], ans[1005]; // debug : char ans[N + 5]; -&gt; 空行，或是$ Xshellint main() &#123; // 字符串输入 cin &gt;&gt; num1 &gt;&gt; num2; n1[0] = strlen(num1); // 首位存储大整数的长度 n2[0] = strlen(num2); ans[0] = max(n1[0], n2[0]); // 取加法结果的最小位数 // 倒序存储，有利于低位对齐和进位 for (int i = 1, j = n1[0] - 1; i &lt;= n1[0]; i++, j--) &#123; // debug : int i = 1, j = n1[0];... -&gt; 符号&#x27;-&#x27; n1[i] = num1[j] - &#x27;0&#x27;; &#125; for (int i = 1, j = n2[0] - 1; i &lt;= n2[0]; i++, j--) &#123; // debug : ...; j &lt;= n2[0];... -&gt; segment fault n2[i] = num2[j] - &#x27;0&#x27;; &#125; // 相加 for (int i = 1; i &lt;= ans[0]; i++) &#123; ans[i] = n1[i] + n2[i]; // ans[i] 用整形存放两加数对应位置的相加结果 &#125; // 处理进位 for (int i = 1; i &lt;= ans[0]; i++) &#123; if (ans[i] &gt; 9) &#123; ans[i + 1] += ans[i] / 10; // 先处理后一位 ans[i] %= 10; // 再处理当前位 // 最后一位有进位，循环条件 i &lt; ans[0]中ans[0] 自增 if (i == ans[0]) &#123; ans[0]++; &#125; &#125; &#125; // 输出答案 for (int i = ans[0]; i &gt; 0; i--) &#123; cout &lt;&lt; ans[i]; &#125; cout &lt;&lt; endl; return 0;&#125; Euler13：一百个50位数的和的前十位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/************************************************************************* &gt; File Name: euler13.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 大和： 求一下一百个50位数的和的前十位数字// debug : 6397775479 -&gt; 验算方法本身出问题 ： 忽略了进位需要右对齐 #include &lt;iostream&gt;#include &lt;cstring&gt;#define N 100using namespace std;char num[N + 5];int n[N + 5], ans[N + 5];void myadd(char *num) &#123; n[0] = strlen(num); ans[0] = max(ans[0], n[0]); for (int i = 1, j = n[0] - 1; i &lt;= n[0]; i++, j--) &#123; // debug : ...j = ans[0] - 1; i &lt;= ans[0];... -&gt; ans[1]的位置出现了负数 n[i] = num[j] - &#x27;0&#x27;; ans[i] += n[i]; // debug : ans[i] += num[i] -&gt; 能输出数据，但是数据 &#125; for (int i = 1; i &lt;= ans[0]; i++) &#123; if (ans[i] &gt; 9) &#123; ans[i + 1] += ans[i] / 10; ans[i] %= 10; if (i == ans[0]) &#123; ans[0]++; &#125; &#125; &#125; return ;&#125;void output() &#123; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; ans[ans[0] - i]; &#125; cout &lt;&lt; endl; return ;&#125;/*void output_all() &#123; for (int i = ans[0]; i &gt; 0; i--) &#123; cout &lt;&lt; ans[i]; &#125; cout &lt;&lt; endl;&#125;*/int main() &#123; for (int i = 1; i &lt;= 100; i++) &#123; cin &gt;&gt; num; myadd(num); // output_all(); // debug : printf法 &#125; output(); return 0;&#125;// Answer: 5537376230 OJ747：大整数减法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/************************************************************************* &gt; File Name: oj747.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; // C++标准程序库中的所有标识符都定义在一个名为std的namespace中char num1[1005], num2[1005];int n1[1005], n2[1005], ans[1005], flag[1005]; // flag[i]用来标记每一位的正负号int main() &#123; scanf(&quot;%d %d&quot;, &amp;n1[0], &amp;n2[0]); // scanf是一种比较快的输入，scanf和printf配套使用， cin与cout配套，否则运行很慢 scanf(&quot;%s&quot;, num1); scanf(&quot;%s&quot;, num2); flag[0] = n1[0] - n2[0]; ans[0] = max(n1[0], n2[0]); // 始终保证被减数大于减数 if (flag[0] == 0) &#123; if (strcmp(num1, num2) &lt; 0) &#123; swap(num1, num2); // &lt;algorithm&gt;包含在std中，可用于交换数组 swap(n1[0], n2[0]); flag[0] = -1; // 结果为负 &#125; &#125; else if (flag[0] &lt; 0) &#123; swap(num1, num2); swap(n1[0], n2[0]); flag[0] = -1; &#125; // 倒序输入 for (int i = n1[0], j = 0; i &gt; 0; i--, j++) &#123; n1[i] = num1[j] - &#x27;0&#x27;; &#125; for (int i = n2[0], j = 0; i &gt; 0; i--, j++) &#123; n2[i] = num2[j] - &#x27;0&#x27;; &#125; // 相减 for (int i = 1; i &lt;= ans[0]; i++) &#123; ans[i] = n1[i] - n2[i]; &#125; // 退位 for (int i = 1; i &lt;= ans[0]; i++) &#123; if (ans[i] &lt; 0) &#123; flag[i] = 1; ans[i + 1] -= flag[i]; ans[i] += flag[i] * 10; &#125; if (i == ans[0] &amp;&amp; ans[i] == 0) &#123; // debug : i = ans[0]... -&gt; 赋值语句引起的死循环 ans[0]--; &#125; &#125; // 输出结果 if (flag[0] == -1) printf(&quot;%s&quot;, &quot;-&quot;); for (int i = ans[0]; i &gt; 0; i--) &#123; printf(&quot;%d&quot;, ans[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 大整数乘法代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/************************************************************************* &gt; File Name: mul.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;char num1[1005], num2[1005];int n1[1005], n2[1005], ans[1005];int main() &#123; cin &gt;&gt; num1 &gt;&gt; num2; n1[0] = strlen(num1); n2[0] = strlen(num2); ans[0] = n1[0] +n2[0] - 1; // 相乘之后的位数 for (int i = n1[0], j = 0; i &gt; 0; i--, j++) &#123; n1[i] = num1[j] - &#x27;0&#x27;; // debug : n1[i] = num[j]; -&gt; 计算结果多位数 &#125; for (int i = n2[0], j = 0; i &gt; 0; i--, j++) &#123; n2[i] = num2[j] - &#x27;0&#x27;; &#125; for (int i = 1; i &lt;= n1[0]; i++) &#123; for (int j = 1; j &lt;= n2[0]; j++) &#123; ans[i + j - 1] += n1[i] * n2[j]; // 相乘之后的相同位置的数据进行相加 &#125; &#125; for (int i = 1; i &lt;= ans[0]; i++) &#123; if (ans[i] &gt; 9) &#123; ans[i + 1] += ans[i] / 10; // 进位可能不止一位 ans[i] %= 10; if (i == ans[0]) &#123; ans[0]++; &#125; &#125; &#125; for (int i = ans[0]; i &gt; 0; i--) &#123; cout &lt;&lt; ans[i]; &#125; cout &lt;&lt; endl; return 0;&#125; Euler25：1000位斐波那契数1234567891011121314151617181920212223242526272829303132333435/************************************************************************* &gt; File Name: euler25.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/#include&lt;iostream&gt;using namespace std;int func(int *n1, int *n2) &#123; n2[0] = n1[0]; for (int i = 1; i &lt;= n2[0]; i++) &#123; n2 [i] += n1[i]; if (n2[i] &gt; 9) &#123; n2[i + 1] += n2[i] / 10; n2[i] %= 10; if (i == n2[0]) &#123; n2[0]++; &#125; &#125; &#125; return n2[0] &gt;= 1000; // 一次func调用后， n2中存储fib(n)中的数据&#125;int main() &#123; int num[2][1100] = &#123;&#123;1, 1&#125;, &#123;1 ,1&#125;&#125;; // 初始化数组： 第一位：斐波那契数的位数 第二位：斐波那契数的个位数 int a = 0, b = 1; for (int i = 3; ; i++) &#123; // i = 3， i = 1, 2已经初始化 if (func(num[a], num[b])) &#123; cout &lt;&lt; i &lt;&lt; endl; // 输出i break; // break， 否则死循环 &#125; swap(a, b); // 指针交换： 交换后，始终让n1指向fib(n - 1), n2 始终指向 fib(n - 2) &#125; return 0;&#125;// 4782 实现带负数的高精度乘法12345678// 将负号作为字符输入后，用flag进行标记int flag = 0;if (num1[0] == &#x27;-&#x27;) &#123; flag = !flag;&#125;if (num2[0] == &#x27;-&#x27;) &#123; flag = !flag;&#125; OJ475： 大整数除法思路： 小学除法模拟竖式 被除数， 除数， 待除数， 除数与被除数相减 数字存储倒着存方便 待除数也是大整数 每次拿下被除数的一位放到待除数中 判断待除数和除数谁大 大整数减法，对应商加一 方法一： 12341. 大量的使用函数宏2. ncmp字典序3. 逆序存储4. 减法过渡到乘法：mul10的操作 方法二： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/**************************************************************************File Name : 475-big-div.cpp*Author : Zsl*mail : zsl_hfut@163.com*Created Time: Sat 26 Dec 2020 10:40:15 AM CST*************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool substract(string a, string b, string &amp;ans) &#123; if(a.size() &lt; b.size()||(a.size() == b.size() &amp;&amp; a &lt; b))&#123; return false; &#125; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); for(string::size_type i = 0;i &lt; b.size(); ++i) &#123; a[i] = a[i] - b[i] + &#x27;0&#x27;; &#125; ans = move(a); for(string::size_type i = 1;i &lt; ans.size(); ++i) &#123; if(ans[i - 1] &lt; &#x27;0&#x27;)&#123; ans[i - 1] += 10; ans[i] -= 1; &#125; &#125; for(string::size_type i = ans.size() - 1;i &gt;= 0; --i)&#123; if(ans[i] == &#x27;0&#x27;)&#123; ans.pop_back(); &#125;else&#123; break; &#125; &#125; return true;&#125;int main() &#123; string N, M; string remainde; string ans; cin &gt;&gt; N &gt;&gt; M; for(string::size_type i = 0; i &lt; M.size(); ++i)&#123; remainde.push_back(M[i]); bool flag = true; while(substract(remainde, N, remainde))&#123; reverse(remainde.begin(), remainde.end()); if(flag)&#123; ans.push_back(&#x27;1&#x27;); &#125;else &#123; ans[ans.size() - 1] += 1; &#125; flag = false; &#125; if(flag &amp;&amp; ans.size())&#123; ans.push_back(&#x27;0&#x27;); &#125; &#125; if(ans.empty()) ans.push_back(&#x27;0&#x27;); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;// c++实现 OJ476：大整数取余1 动态规划与递推Euler15-网格路径动态规划123456789101112131415161718192021222324/************************************************************************* &gt; File Name: euler15_dp.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 题意理解：因为每一条路径都是独立的，经过点dp[i][j]的路径数等于左边来的路径数加上上面来的路径数#include&lt;iostream&gt;using namespace std;long long dp[25][25];int main() &#123; for (int i = 1; i &lt;= 21; i++) &#123; // 数组在从（1,1）开始：避免数组越界，而且初始化为零不影响计算 for (int j = 1; j &lt;= 21; j++) &#123; // 细节：表面上为 2 * 2 实际上为 3 * 3 if (i == 1 &amp;&amp; j == 1) &#123; // 用 if else 来实现初始化，因为dp[1][1]是个特殊值 dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 核心就是求出递推公式 &#125; &#125; &#125; cout &lt;&lt; dp[21][21] &lt;&lt; endl; return 0;&#125;// 137846528820 排列组合12345678910111213141516171819/************************************************************************* &gt; File Name: euler15_ac.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 以2*2为例，到达最下点，必定向下两格，向右两格，但是顺序可以组合 C(4, 2)// 公式：C(n ,m) = (n!) / m!(n - m)!#include&lt;iostream&gt;using namespace std;int main() &#123; long long ans = 1; // debug : int ans = 1; -&gt; 106285226, int 类型到10^9，要注意 for (int i = 40, j = 1; i &gt;20; i--, j++) &#123; ans *= i; ans /= j; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;// 137846528820 Euler18-最大路径和数据1234567891011121314157595 6417 47 8218 35 87 1020 04 82 47 6519 01 23 75 03 3488 02 77 73 07 63 6799 65 04 28 06 16 70 9241 41 26 56 83 40 80 70 3341 48 72 33 47 32 37 16 94 2953 71 44 65 25 43 91 52 97 51 1470 11 33 28 77 73 17 78 39 68 17 5791 71 52 38 17 14 91 43 58 50 27 29 4863 66 04 68 89 53 67 30 73 16 69 87 40 3104 62 98 27 23 09 70 98 73 93 38 53 60 04 23 自上而下123456789101112131415161718192021222324252627/************************************************************************* &gt; File Name: euler18_utd.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/#include&lt;iostream&gt;using namespace std;int num[20][20], n;int main() &#123; n = 15; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; cin &gt;&gt; num[i][j]; &#125; &#125; int ans = 0; // 不需要定义 ans[20][20], ans每到新的一层都更新，中间计算值存放在num[i][j]中 for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; num[i][j] += max(num[i - 1][j - 1], num[i - 1][j]); // 比较＋累加 ans = max(ans ,num[i][j]); // 让max替换if(num[i][j] &gt; ans)语句吧 &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;// 1074 自下而上1234567891011121314151617181920212223242526/************************************************************************* &gt; File Name: euler18_dtu.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 自上而下与自下而上的时间复杂度一样#include&lt;iostream&gt;using namespace std;int num[20][20], n;int main() &#123; n = 15; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j&lt;= i; j++) &#123; cin &gt;&gt; num[i][j]; &#125; &#125; for (int i = n - 1; i &gt; 0; i--) &#123; for (int j = 1; j &lt;= i; j++) &#123; num[i][j] += max(num[i + 1][j], num[i + 1][j + 1]); &#125; &#125; cout &lt;&lt; num[1][1] &lt;&lt; endl; // 无需遍历答案值，答案直接在最上面, 也不会越界 return 0;&#125;// 1074 OJ590：树塔狂想曲12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/************************************************************************* &gt; File Name: oj590.cpp &gt; Mail: 1136984246@qq.com ************************************************************************/// 空间换时间的典型例子：// 方法1： 标记ban掉的值，把该值设为无穷小； 由于ban的次数在10^5, 容易超时// 方法2： 空间换时间（先存储答案，后面直接找答案）：计算经过指定点(i ,j)的最大路径值; ban掉第 i 行的最大值，取次大值，否则取最大值#include&lt;iostream&gt; #include &lt;cstdio&gt;using namespace std;int n, m, num[1005][1005], utd[1005][1005], dtu[1005][1005], ans[1005][1005], mmax[1005], sec[1005];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; scanf(&quot;%d&quot;, &amp;num[i][j]); // 把cin快 utd[i][j] = max(utd[i - 1][j - 1], utd[i - 1][j]) + num[i][j]; &#125; &#125; for (int i = n; i &gt; 0; i--) &#123; for (int j = 1; j &lt;= i; j++) &#123; dtu[i][j] = max(dtu[i + 1][j + 1], dtu[i + 1][j]) + num[i][j]; ans[i][j] = utd[i][j] + dtu[i][j] - num[i][j]; // 计算经过指定点(i ,j)的最大路径值 &#125; &#125; for (int i = 2; i &lt;= n; i++) &#123; int m1 = 0, m2 = 0, ind = 0; // m1 : 最大值， m2 : 次大值，ind ： 最大值的坐标 for (int j = 1; j &lt;= n; j++) &#123; // 注意更新最大值和次大值的顺序 if (ans[i][j] &gt; m1) &#123; m2 = m1; m1 = ans[i][j]; ind = j; // 如果最大值没有更新，则更新次大值 // 次大值和最大值可能相同 &#125; else if (ans[i][j] &gt; m2) &#123; // debug : if (...) 缺少else -&gt; 最大值和次大值都是一样大 m2 = ans[i][j]; &#125; &#125; mmax[i] = ind; // 采用ind, m1，m2 作为中间变量 sec[i] = m2; &#125; for (int i = 0; i &lt; m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (x == 1) &#123; printf(&quot;-1\\n&quot;); &#125; else if (y == mmax[x]) &#123; // mmax[x]存取第x行最大值的坐标 printf(&quot;%d\\n&quot;, sec[x]); // sec[x]存取第x行次大值的值 &#125; else &#123; printf(&quot;%d\\n&quot;, dtu[1][1]); // 最大值的答案直接在dtu[1][1] == ans[x][mmax[x]]; &#125; &#125; return 0;&#125;// oj测试，注意不要scanf与cout混用","categories":[],"tags":[]},{"title":"","slug":"基于hexo搭建个人博客","date":"2020-12-23T03:30:15.424Z","updated":"2020-12-23T03:30:15.424Z","comments":true,"path":"2020/12/23/基于hexo搭建个人博客/","link":"","permalink":"http://example.com/2020/12/23/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"利用hexo搭建个人博客基本概念静态博客与动态博客 网页 区别 维护 形式 动态网页[^3] 只有HTML，无数据库支持 修改内容（要重新上传）,容易检索 后缀常为.htm, .html, .shtml 静态网页 有代码（浏览器与服务器交互） 容易修改，有数据库技术，不易检索 大部分网页（搜索引擎的跳转） 环境：hexo[^1]框架Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。 git[^2]Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 基本思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 安装git 查看版本sudo apt install git# 安装nodejs 与 工具npmsudo apt install nodejssudo apt install npm# 查看版本(判断是否安装成功)node -vnpm -v# 新建目录~/blog, 安装hexo(全局安装)# 基于blog来做,感觉不爽直接干掉该目录即可# bug 1 : 没有权限, 关键词: permission # 解决: 用户层面:usermod, sudo 文件层面: chmod, 比如usermod -a -G root,sudo blogchmod g=wrx /usr/local/bin # bug 2 : 版本不兼容 报错: wanted: &#123;&quot;node&quot;:&quot;&gt;=10.13.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;8.10.0&quot;,&quot;npm&quot;:&quot;3.5.2&quot;&#125;)# 解决: 从NodeSource中安装nodejs和npmcurl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - # 创建一个apt源,并刷新apt缓存sudo apt install nodejs # nodejs 软件包同时包含node和npm二进制包node -vnpm -v# 解决: 利用npm的淘宝镜像cnpm安装hexonpm install -g cnpm --registry=http://registry.npm.taobao.orgcnpm # npm访问较慢cnpm -v# 利用cnpm安装 hexocnpm install -g hexo-clihexo -v# hexo基本操作# 初始化hexohexo init myblognmp install # myblog下有public:页面, scaffolds: 模板; source : 文章; themes : 主题 _config.yml: 配置文件# 写本地博客hexo new &quot;我的第一篇博客&quot;# 删除博客只需要把*.md删除,在 hexo clean即可# 本地浏览博客 hexo generatehexo server# github创建仓库# 注意仓库名和用户名要重合 : username.github.io # 安装git的部署插件cnpm install --save hexo-deployer-git # 设置配置文件_config.yml# Deploymenttype: gitrepo: http://github.com/Troy-Lee.github.io.gitbrach: master# 配置本地 gitgit config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;# 部署远端(输入账号,密码) hexo generatehexo deploy# 改主题# 下载主题git clone https://github.com/litten/hexo-theme-yilia.git themes/yiliagit clone https://github.com.cnpmjs.org/litten/hexo-theme-yilia.git themes/yilia# 修改_config.ylm中的themetheme: yilia 参考文献全网最全hexo博客部署[^ 1 ]: hexo官网[^ 2 ]: 廖雪峰git教程[^ 3 ]: JSP +Servlet[^ 4 ]: nodejs官方文档[^ 5 ]: hexo手册","categories":[],"tags":[]},{"title":"hello","slug":"hello","date":"2020-12-22T13:38:08.000Z","updated":"2021-01-22T02:37:05.946Z","comments":true,"path":"2020/12/22/hello/","link":"","permalink":"http://example.com/2020/12/22/hello/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"系统编程","slug":"计算机/系统编程","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"面试笔试算法","slug":"计算机/面试笔试算法","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"系统编程与网络编程","slug":"系统编程与网络编程","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"面试笔试算法","slug":"面试笔试算法","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95/"}]}